### 21. 소프트웨어 패키징 도구 활용시 고려 사항

#### 소프트웨어 패키징

모듈별로 생성한 실행 파일들을 묶어 배포용 설치 파일을 만드는 것

- 사용자 중심
- 소스 코드는 모듈화하여 패키징: 향후 관리를 고려
- 사용자가 다양한 환경에서 소프트웨어를 손쉽게 사용할 수 있도록 일반적인 배포 형태로 패키징

#### 고려사항

- 사용자의 최소 필요 시스템 환경(OS, CPU, 메모리 등)에 대해 정의
- UI는 시각적인 자료와 함께 제공, 매뉴얼과 일치시켜 패키징
- 소프트웨어는 하드웨어와 함께 관리될 수 있도록 단순 패키징 배포가 아닌 Managed Service 형태로 제공
- 다른 여러 콘텐츠 및 단말기 간 DRM(디지털 저작권 관리) 연동을 고려
- 사용자의 편의성 고려 → 복잡성 및 비효율성 문제
- 적합한 암호화 알고리즘 적용

#### 패키징 작업 순서

1. 기능 식별: 작성된 코드의 기능을 확인
2. 모듈화: 확인된 기능 단위로 코드를 분류
3. 빌드 진행: 모듈 단위로 실행 파일 생성
4. 사용자 환경 분석: 웹, 모바일, PC 등 소프트웨어가 사용될 환경이나  
   운영체제, CPU, RAM 등의 최소 운영 환경 정의
5. 패키징 및 적용 시험
   - 빌드된 실행 파일들을 정의도니 환경에 맞게 배포용 파일 형식으로 패키징
   - 정의된 환경과 동일한 환경에서 패키징 결과를 테스팅
   - 소프트웨어에 대한 불편사항을 사용자 입장에서 확인
6. 패키징 변경 개선: 확인된 불편 사항을 반영하여 진행
7. 배포: 배포 수행 시 오류가 발생하면 해당 개발자에게 수정 요청

---

### 22. EAI(Enterprise Application Integration) 구축 유형 - Hybrid

모듈 연계는 내부 모듈과 외부 모듈 또는 내부 모듈 간 데이터의 교환을 위해 관계를 설정하는 것으로, 대표적인 모듈 연계 방법에는 EAI와 ESB가 있다

#### EAI(Enterprise Application Integration)

- 기업 내 각종 애플리케이션 및 플랫폼 간의 정보 전달, 연계, 통합 등 상호 연동이 가능하게 해주는 솔루션
- 비즈니스 간 통합 및 연계성을 증대 → 효율성 및 각 시스템간의 확장성 ▲

| 구축 유형                 | 기능                                                                                                                                                                                         |
| ------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Point-to-Point            | - 가장 기본적인 애플리케이션 통합 방식<br>- 애플리케이션을 1:1로 연결<br>- 변경 및 재사용이 어렵다                                                                                           |
| Hub & Spoke               | - 중앙 집중형 방식<br>- 단일 접점인 허브 시스템을 통해 데이터 전송<br>- 확장 및 유지 보수가 용이<br>- 허브 장애 발생 시 시스템 전체에 영향                                                   |
| Message Bus<br>(ESB 방식) | - 애플리케이션 사이에 미들웨어를 두어 처리하는 방식<br>- 확장성이 뛰어나며 대용량 처리가 가능                                                                                                |
| Hybrid                    | - Hub & Spoke와 Message Bus의 혼합 방식<br>- 그룹 내에서는 Hub & Spoke 방식<br>- 그룹 간에는 Message Bus 방식<br>- 필요한 경우 한 가지 방식으로 EAI 구현 가능<br>- 데이터 병목 현상을 최소화 |

#### ESB(Enterprise Services Bus)

- 애플리케이션 간 연계, 데이터 변환, 웹 서비스 지원 등 표준 기반의 인터페이스를 제공하는 솔루션
- 애플리케이션 통합 측면에서 EAI와 유사하지만, 애플리케이션 보다는 서비스 중심의 통합을 지향
- 특정 서비스에 국한되지 않고 범용적으로 사용하기 위하여  
  애플리케이션과의 결합도를 약하게 유지
- 관리 및 보안 유지가 쉽고, 높은 수준의 품질 지원이 가능

---

### 23. 소스 코드 품질 분석 도구 - 정적 분석 도구

| 클린 코드 작성 원칙 | 설명                                                                                                                       |
| ------------------- | -------------------------------------------------------------------------------------------------------------------------- |
| 가독성              | - 누구든지 코드를 쉽게 읽을 수 있도록 작성한다<br>- 코드를 작성 시 이해하기 쉬운 용어를 사용하거나 들여쓰기 기능 등을 사용 |
| 단순성              | - 코드를 간단하게 작성<br>- 한 번에 한 가지를 처리하도록 코드를 작성<br>- 클래스/메소드/함수 등을 최소 단위로 분리         |
| 의존성 배제         | - 코드가 다른 모듈에 미치는 영향을 최소화<br>- 코드 변경 시 다른 부분에 영향이 없도록 작성                                 |
| 중복성 최소화       | - 코드의 중복을 최소화<br>- 중복된 코드는 삭제하고 공통된 코드를 사용                                                      |
| 추상화              | 상위 클래스/메소드/함수에서는 간략하게 애플리케이션의 특성을 나타내고,<br>상세 내용은 하위 클래스/메소드/함수에서 구현     |

#### 소스 코드 품질 분석 도구

- 정적 분석 도구

  - 작성한 소스 코드를 실행하지 않고 코딩 표준이나 코딩 스타일, 결함 등을 확인하는 코드 분석 도구
  - 비교적 애플리케이션 개발 초기의 결함을 찾는데 사용
  - 개발 완료 시점에서는 개발된 소스 코드의 품질을 검증하는 차원에서 사용
  - 자료 흐름이나 논리 흐름을 분석하여 비정상적인 패턴을 찾을 수 있다
  - 동적 분석 도구로는 발견하기 어려운 결함을 찾아내고,  
    소스 코드에서 코딩의 복잡도, 모델 의존성, 불일치성 등을 분석할 수 있다
  - 종류: pmd, cppcheck, SonarQube, checkstyle, ccm, cobertura 등

- 동적 분석 도구
  - 작성한 소스코드를 실행하여 코드에 존재하는 메모리 누수, 스레드 결함 등을 분석하는 도구
  - 종류: Avalanche, Valgrind 등

| 도구       | 설명                                                                                              | 지원환경       |
| ---------- | ------------------------------------------------------------------------------------------------- | -------------- |
| pmd        | 소스 코드에 대한 미사용 변수, 최적화되지 않은 코드 등<br>결함을 유발할 수 있는 코드를 검사        | Linux, Windows |
| cppcheck   | C/C++ 코드에 대한 메모리 누수, 오버플로우 등 분석                                                 | Windows        |
| SonarQube  | 중복 코드, 복잡도, 코딩 설계 등을 분석하는 소스 분석 통합 플랫폼                                  | Cross-Platform |
| checkstyle | - 자바 코드에 대해 소스 코드 표준을 따르고 있는지 검사<br>- 다양한 개발 도구에 통합하여 사용 가능 | Cross-Platform |
| ccm        | 다양한 언어의 코드 복잡도를 분석                                                                  | Cross-Platform |
| cobertura  | 자바 언어의 소스 코드 복잡도 분석 및 테스트 커버리지를 측정                                       | Cross-Platform |
| Avalanche  | - Valgrind 프레임워크 및 STP 기반으로 구현<br>- 프로그램에 대한 결함 및 취약점 등을 분석          | Linux, Android |
| Valgrind   | 프로그램 내에 존재하는 메모리 및 쓰레드 결함 등을 분석                                            | Cross-Platform |

---

### 24. Postfix 연산식

#### 수식의 표기법

- 전위 표기법(PreFix): 연산자 → Left → Right, +AB
- 중위 표기법(InFix): Left → 연산자 → Right, A+B
- 후위 표기법(PostFix): Left → Right → 연산자, AB+

#### 사용 예시

PreFix 예시

`+ / A - B C * D + E F`  
→ `(+ (/ A (- B C)) (* D (+ E F)))`  
→ `((A / (B - C)) + (D * ( E + F)))`

PostFix 예시

`3 4 * 5 6 * +`  
→ `((3 4 *)(5 6 *) +)`  
→ `((3 * 4) + (5 * 6))` → 42

---

### 25. 인터페이스 보안을 위해 네트워크 영역에 적용될 수 있는 것

IPSec, SSL, S-HTTP

#### 인터페이스 보안

인터페이스는 서로 다른 시스템 사이에서 데이터를 원활히 주고받을 수 있는 통로로 사용되므로  
데이터 변조 및 탈취 등의 위협에 노출되어 있다  
인터페이스의 보안성 향상을 위해서는 인터페이스가 구현되는 각 구간에서  
보안에 취약한 부분을 확인한 후 알맞은 보안 기능을 적용해야 한다

- 네트워크 영역
  - 인터페이스 송·수신 간 스니핑 등을 이용한 데이터 탈취 및 번조 위협을 방지하기 위해  
    네트워크 트래픽에 대한 암호화를 설정
  - 암호화는 인터페이스 아키텍처에 따라 IPSec, SSL, S-HTTP 등의 다양한 방식을 사용
- 애플리케이션 영역
  - 소프트웨어 개발 보안 가이드를 참조하여  
    애플리케이션 코드 상의 보안 취약점을 보완하는 방향으로 애플리케이션 보안 기능을 적용
- 데이터베이스 영역
  - 데이터베이스, 스키마, 엔티티의 접근 권한과  
    프로시저, 트리거 등 데이터베이스 동작 객체의 보안 취약점에 보안 기능을 적용
  - 개인 정보나 업무상 민감한 데이터의 경우 암호화나 익명화 등 데이터 자체의 보안 방안도 고려

---

### 26. 검증(Validation) 검사 기법

V-모델: 소프트웨어 개발 단계와 애플리케이션 테스트를 연결하여 표현

![alt text](../img/124603.png)

#### 단위 테스트

코딩 직후 소프트웨어 설계의 최소 단위인 모듈이나 컴포넌트에 초점을 맞춰 테스트

- 인터페이스, 외부적I/O, 자료 구조, 독립적 기초 경로, 오류 처리 경로, 경계 조건 등을 검사
- 사용자의 요구사항을 기반으로 한 기능성 테스트를 최우선으로 수행
- 구조 기반 테스트와 명세 기반 테스트로 나뉘지만 주로 구조 기반 테스트를 시행
- 단위 테스트로 발견 가능한 오류
  - 알고리즘 오류에 따른 원치 않는 결과
  - 탈출구가 없는 반복문의 사용
  - 틀린 계산 수식에 의한 잘못된 결과

| 테스트 방법      | 테스트 내용                                                       | 테스트 목적             |
| ---------------- | ----------------------------------------------------------------- | ----------------------- |
| 구조 기반 테스트 | 프로그램 내부 구조 및 복잡도를 검증하는<br>화이트박스 테스트 시행 | 제어흐름, 조건 결정     |
| 명세 기반 테스트 | 목적 및 실행 코드 기반의<br>블랙박스 테스트 시행                  | 동등 분할, 경계 값 분석 |

#### 통합 테스트

단위 테스트가 완료된 모듈들을 결합하여 하나의 시스템으로 완성시키는 과정에서의 테스트  
통합 테스트는 모듈 간 또는 통합된 컴포넌트 간의 상화 작용 오류를 검사

#### 시스템 테스트

- 개발된 소프트웨어가 해당 컴퓨터 시스템에서 완벽하게 수행되는가를 점검하는 테스트
- 환경적인 장애 리스크를 최소화하기 위해  
  실제 사용 환경과 유사하게 만든 테스트 환경에서 테스트를 수행

| 테스트 방법       | 설명                                                                                                                                  |
| ----------------- | ------------------------------------------------------------------------------------------------------------------------------------- |
| 기능적 요구사항   | 요구사항 명세서, 비즈니스 절차, 유스케이스 등<br>명세서 기반의 블랙박스 테스트 시행                                                   |
| 비기능적 요구사항 | 성능 테스트, 회복 테스트, 보안 테스트, 내부 시스템의 메뉴구조,<br>웹 페이지의 네비게이션 등 구조적 요소에 대한 화이트박스 테스트 시행 |

#### 인수 테스트

개발한 소프트웨어가 사용자의 요구사항을 충족하는지에 중점을 두고 테스트하는 방법

- 개발한 소프트웨어를 사용자가 직접 테스트
- 문제가 없으면 사용자는 소프트웨어를 인수, 프로젝트는 종료

| 테스트 종류          | 설명                                                                                                                                                                                                                                                        |
| -------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 사용자 인수 테스트   | 사용자가 시스템 사용의 적절성 여부를 확인                                                                                                                                                                                                                   |
| 운영상의 인수 테스트 | 시스템 관리자가 시스템 인수 시 수행하는 테스트 기법<br>백업/복원 시스템, 재난 복구, 사용자 관리, 정기 점검 등을 확인                                                                                                                                        |
| 계약 인수 테스트     | 계약상의 인수/검수 조건을 준수하는지 여부를 확인                                                                                                                                                                                                            |
| 규정 인수 테스트     | 소프트웨어가 정부 지침, 법규, 규정 등 규정에 맞게 개발되었는지 확인                                                                                                                                                                                         |
| 알파 테스트          | - 개발자의 장소에서 사용자가 개발자 앞에서 행하는 테스트 기법<br>- 테스트는 통제된 환경에서 진행<br>- 오류와 사용상의 문제점을 사용자와 개발자가 함께 확인하면서 기록                                                                                       |
| 베타 테스트          | - 선정된 최종 사용자가 여러 명의 사용자 앞에서 행하는 테스트 기법<br>- 필드 테스팅<br>- 실업무를 가지고 사용자가 직접 테스트하는 것<br>- 개발자에 의해 제어되지 않은 상태에서 진행<br>- 발결된 오류와 사용상의 문제점을 기록하고 개발자에게 주기적으로 보고 |

---

### 27. 삽입 정렬(Insertion Sort)

이미 순서화된 파일에 새로운 하나의 레코드를 순서에 맞게 삽입시켜 정렬

- 두 번째 키와 첫 번째 키를 비교해 순서대로 나열하고,  
  이어서 세 번째 키를 첫 번째, 두 번째 키와 비교해 순서대로 나열하고,  
  계속해서 n번째 키를 앞의 n-1개의 키와 비교하여 알맞은 순서에 삽입하여 정렬하는 방식
- 평균과 최악 모두 수행 시간 복잡도는 O(n²)

> 초기 자료: 8, 3, 4, 9, 7  
> → 1회전: 3, 8, 4, 9, 7 → 2회전: 3, 4, 8, 9, 7 → 3회전: 3, 4, 8, 9, 7 → 4회전: 3, 4, 7, 8, 9

---

### 28. 소프트웨어 설치 매뉴얼

- 사용자 기준으로 작성
- 설치 시작부터 완료할 때까지의 전 과정을 빠짐없이 순서대로 설명
- 설치 과정에서 표시될 수 있는 오류 메시지 및 예외 상황에 관한 내용을 별도로 분류하여 설명
- 목차 및 개요, 서문, 기본 사항 등이 기본적으로 포함
- 전체 설치 과정을 순서대로 요약한 후 관련 내용의 시작 페이지를 함께 기술
- 설치 매뉴얼의 주요 특징, 구성과 설치 방법, 순서 등의 내용을 기술

#### 기본 사항

| 항목            | 설명                                                                                     |
| --------------- | ---------------------------------------------------------------------------------------- |
| 소프트웨어 개요 | - 소프트웨어의 주요 기능 및 UI 설명<br>- UI 및 화면 상의 버튼, 프레임 등을 그림으로 설명 |
| 설치 관련 파일  | - 소프트웨어 설치에 필요한 파일 설명<br>- exe, ini, log 등의 파일 설명                   |
| 설치 아이콘     | 설치 아이콘 설명                                                                         |
| 프로그램 삭제   | 설치된 소프트웨어의 삭제 방법 설명                                                       |
| 관련 추가 정보  | - 소프트웨어 이외의 관련 설치 프로그램 정보<br>- 소프트웨어 제작사 등의 추가 정보 기술   |

---

### 29. 인터페이스 구현 검증 도구

인터페이스 구현 검증은 인터페이스가 정상적으로 문제없이 작동하는지 확인

| 도구     | 기능                                                                                                                                                                                                                                                                                                                          |
| -------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| xUnit    | - 같은 테스트 코드를 여러 번 작성하지 않게 도와주고, 테스트마다 예상 결과를 기억할 필요가 없게 하는 자동화된 해법을 제공하는 단위 프레임워크<br>- Smalltalk에 처음 적용되어 SUnit이라는 이름이었으나, Java용의 JUnit, C++용의 CpplUnit, .NET용의 NUnit, Http용의 HttpUnit 등 다양한 언어에 적용되면서 xUnit으로 통칭되고 있다 |
| STAF     | - 서비스 호출 및 컴포넌트 재사용 등 다양한 환경을 지원하는 테스트 프레임워크<br>- 크로스 플랫폼, 분산 소프트웨어 테스트 환경을 조성할 수 있도록 지원<br>- 분산 소프트웨어의 각 분산 환경에 설치된 데몬이 프로그램 테스트에 대한 응답을 대신하며, 테스트가 완료되면 이를 통합하고 자동화하여 프로그램을 완성                   |
| FitNesse | 웹 기반 테스트케이스 설계, 실행, 결과 확인 등을 지원하는 테스트 프레임워크                                                                                                                                                                                                                                                    |
| NTAF     | FitNesse의 장점인 협업 기능과 STAF의 장점인 재사용 및 확장성을 통합한 NHN의 테스트 자동화 프레임워크                                                                                                                                                                                                                          |
| Selenium | 다양한 브라우저 및 개발 언어를 지원하는 웹 애플리케이션 테스트 프레임워크                                                                                                                                                                                                                                                     |
| watir    | Ruby를 사용하는 애플리케이션 테스트 프레임워크                                                                                                                                                                                                                                                                                |

---

### 30. 소프트웨어 형상 관리

형상 관리  
소프트웨어의 개발 과정에서 소프트웨어의 변경 사항을 관리하기 위해 개발된 이련의 활동

- 소프트웨어 변경의 원인을 알아내고 제어하며, 적절히 변경되고 있는지 확인하여 해당 담당자에게 통보
- 형장 관리는 소프트웨어 개발의 전 단계에 적용되는 활동이며, 유지보수 단계에서도 수행
- 관리 항목
  - 소스 코드, 프로젝트 계획, 분석서, 설계서, 프로그램, 테스트 케이스 등
- 형상 관리를 통해 가시성과 추적성을 보장함으로써 소프트웨어의 생산성과 품질을 높일 수 있다
- 대표적인 형상 관리 도구에는 Git, CVS, Subversion 등이 있다

#### 형상 관리의 중요성

- 지속적인 소프트웨어의 변경 사항을 체계적으로 추적하고 통제할 수 있다
- 제품 소프트웨어에 대한 무절제한 변경을 방지할 수 있다
- 제품 소프트웨어에서 발견된 버그나 수정 사항을 추적할 수 있다
- 소프트웨어는 형태가 없어 가시성이 결핍되므로 진행 정도를 확인하기 위한 기준으로 사용될 수 있다
- 소프트웨어의 배포본을 표율적으로 관리할 수 있다
- 소프트웨어를 여러 명의 개발자가 동시에 개발할 수 있다

#### 형상 관리 기능

- 형상 식별: 형상 관리 대상에 이름과 관리 번호를 부여하고, 계층 구조로 구분하여 수정 및 추적이 용이하도록 하는 작업
- 버전 제어: 소프트웨어 업그레이드나 유지 보수 과정에서 생성된 다른 버전의 형상 항목을 관리하고, 이를 위해 특정 철차와 도구를 결합시키는 작업
- 형상 통제(변경 관리): 식별된 형상 항목에 대한 변경 요구를 검토하여 현재의 기준선이 잘 변영될 수 있도록 조정하는 작업
- 형상 감사: 기준선의 무결성을 평가하기 위해 확인, 검증, 검열 과정을 통해 공식적으로 승인하는 작업
- 형상 기록(상태 보고): 형상의 식별, 통제, 감사 작업의 결과를 기록, 관리하고 보고서를 작성하는 작업

---

### 31. 내부 스키마

    물리적 저장 장치의 입장에서 본 데이터베이스 구조로서
    실제로 데이터베이스에 저장될 레코드의 형식을 정의하고
    저장 데이터 항목의 표현 방법, 내부 레코드의 물리적 순서 등을 나타낸다

데이터베이스 개요

**1. 데이터저장소**

- 논리 데이터저장소: 데이터 및 데이터 간의 연관성, 제약조건을 식별하여 논리적인 구조로 조직화한 것
- 물리 데이터저장소: 논리 데이터저장소에 저장된 데이터와 구조들을 소프트웨어가 운용될 환경의 물리적 특성을 고려하여 하드웨어적인 저장장치에 저장한 것

논리 데이터 저장소를 거쳐 물리 데이터저장소를 구축하는 과정은 데이터베이스를 구축하는 과정과 동일하다

**2. 데이터베이스**

- 통합된 데이터: 자료의 중복을 배제한 데이터의 모임
- 저장된 데이터: 컴퓨터가 접근할 수 있는 저장 매체에 저장된 자료
- 운영 데이터: 조직의 고유한 업무를 수행하는 데 존재 가치가 확실하고 없어서는 안 될 반드시 필요한 자료
- 공용 데이터: 여러 응용 시스템들이 공동으로 소유하고 유지하는 자료

**3. DBMS(DataBase Management System, 데이터베이스 관리 시스템)**

DBMS란 사용자와 데이터베이스 사이에서 사용자의 요구에 따라 정보를 생성해주고, 데이터베이스를 관리해 주는 소프트웨어

- 기존의 파일 시스템이 갖는 데이터의 종속성과 중복성의 문제를 해결하기 위해 제안된 시스템으로, 모든 응용 프로그램들이 데이터베이스를 공용할 수 있도록 관리해준다
- 데이터베이스의 구성, 접근 방법, 유지관리에 대한 모든 책임을 진다
- 필수 기능
  - 정의(Definition) 기능: 모든 응용 프로그램들이 요구하는 데이터 구조를 지원하기 위해 데이터베이스에 저장될 데이터의 형(Type)과 구조에 대한 정의, 이용 방식, 제약 조건 등을 명시하는 기능
  - 조작(Manipulation) 기능: 데이터 검색, 갱신, 삽입, 삭제 등을 체계적으로 처리하기 위해 사용자와 데이터베이스 사이의 인터페이스 수단을 제공하는 기능
  - 제어(Control) 기능: 무결성, 권한 검사, 병행 제어

장점

- 데이터의 논리적, 물리적 독립성이 보장
- 데이터의 중복을 피할 수 있어 기억 공간이 절약
- 저장된 자료를 공동으로 이용
- 데이터의 일관성, 무결성, 보안 유지
- 데이터를 표준화
- 데이터를 통합화여 관리
- 항상 최신의 데이터를 유지
- 데이터의 실시간 처리가 가능

단점

- 데이터베이스의 전문가가 부족
- 전산화 비용이 증가
- 대용량 디스크로의 집중적인 Access로 과부하가 발생
- 파일의 예비와 회복이 어려움
- 시스템 복잡

**4. 스키마**

데이터베이스의 구조와 제약 조건에 관한 전반적인 명세를 기술한 메타데이터의 집합

- 스키마는 데이터베이스를 구성하는 데이터 개체(Entity), 속성(Attribute), 관계(Relationship) 및 데이터 조작시 데이터 값들이 갖는 제약 조전 등에 관해 전반적으로 정의
- 사용자의 관점에 따라
  - 외부 스키마: 사용자나 응용 프로그래머가 각 개인의 입장에서 필요로 하는 데이터베이스의 논리적 구조를 정의한 것
  - 개념 스키마
    - 데이터베이스의 전체적인 논리적 구조로서, 모든 응용 프로그램이나 사용자들이 필요로 하는 데이터를 종합한 조직 전체의 데이터베이스로, 하나만 존재한다
    - 개체 간의 관계와 제약 조건을 나타내고, 데이터베이스의 접근 권한, 보안 및 무결성 규칙에 관한 명세를 정의
  - 내부 스키마: 물리적 저장장치의 입장에서 본 데이터베이스 구조로서, 실제로 데이터베이스에 저장될 레코드의 형식을 정의하고 저장 데이터 항목의 표현 방법, 내부 레코드의 물리적 순서 등을 나타낸다

---

### 32. 트리

정점(Node)과 선분(Branch)을 이용하여 사이클을 이루지 않도록 구성한 그래프의 특수 형태

노드(Node): 하나의 기억 공간
링크(Link): 노드와 노드를 연결하는 선

#### 트리 관련 용어

![alt text](../img/150641.png)

- 노드(Node): 트리의 기본 요소로서 자료 항목과 다른 항목에 대한 가지를 합친 것  
  A, B, C, D, E, F, G, H, I, J, K, L, M
- 근 노드(Root Node): 트리의 맨 위에 있는 노드  
  A
- 디그리(Degree, 차수): 각 노드에서 뻗어 나온 가지의 수  
  A = 3, B = 2, C = 1, D = 3, ...
- 단말 노드(Terminal) = 잎 노드(Leaf Node): 자식이 하나도 없는 노드, 즉 디그리가 0인 노드  
  K, L, F, G, M, I, J
- 자식 노드(Son Node): 어떤 노드에 연결된 다음 레벨의 노드들  
  D의 자식 노드 = H, I, J
- 부모 노드(Parent Node): 어떤 노드에 연결된 이전 레벨의 노드들  
  E, F의 부모 노드 = B
- 형제 노드(Brother Node, Sibling): 동일한 부모를 갖는 노드들  
  H의 형제 노드 = I, J
- 트리의 디그리: 노드들의 디그리 중에서 가장 많은 수  
  노드 A나 D가 3개의 디그리를 가지므로 트리의 디그리는 3이다

#### 트리의 운행법

- Preorder 운행: Root → Left → Right
- Inorder 운행: Left → Root → Right
- Postorder 운행: Left → Right → Root

예시)

![alt text](../img/153219.png)

서브트리를 하나의 노드로 생각할 수 있도록 그림과 같이 서브트리 단위로 묶어서 순서를 파악  
(Preorder, Inoder, Postorder 모두 공통으로 사용)

- Preorder: A 1 3 → A B 2 E C F G → A B D H I E C F G
- Inorder: 1 A 3 → 2 B E A F C G → H D I B E A F C G
- Postorder: 1 3 A → 2 E B F G C A → H I D E B F G C A

---

### 33. n개의 노드로 구성된 무방향 그래프의 최대 간선 수는?

그래프 G는 정접 V(Vertex)와 간선 E(Edge)의 두 집합으로 이루어진다

- 간선의 방향성 유무에 따라 방향에 따라 방향 그래프와 무방향 그래프로 구분
- 트리는 사이클이 없는 그래프

**무방향 그래프**

![alt text](../img/163843.png)

최대 간선 수: n(n-1)/2 = 6

**방향 그래프**

![alt text](../img/164300.png)

최대 간선 수: n(n-1) = 12

---

### 34. 테스트 용어

    - 테스트의 결과가 참인지 거짓인지를 판단하기 위해서 사전에 정의된 참값을 입력하여 비교하는 기법 및 활동
    - 종류에는 참, 샘플링, 휴리스틱, 일관성 검사가 존재

    ▷ 테스트 오라클

#### 테스트 케이스

구현된 소프트웨어가 사용자의 요구사항을 정확하게 준수했는지를 확인하기 위해 설계된 입력 값, 실행 조건, 기대 결과 등으로 구성된 테스트 항목에 대한 명세서로, 명세 기반 테스트의 설계 산출물에 해당

- 테스트 케이스를 미리 설계하면 테스트 오류를 방지할 수 있고 테스트 수행에 필요한 인력, 시간 등의 낭비를 줄일 수 있다
- 테스트 케이스는 테스트 목표와 방법을 설정한 후 작성한다
- 테스트 케이스는 시스템 설계 단계에서 작성하는 것이 가장 이상적이다

#### 테스트 시나리오

테스트 케이스를 적용하는 순서에 따라 여러 개의 테스트 케이스들을 묶은 집합으로, 테스트 케이스들을 적용하는 구체적인 절차를 명세한 문서

- 테스트 시나리오에는 테스트 순서에 대한 구체적인 절차, 사전 조건, 입력 데이터 등이 설정되어 있다
- 테스트 시나리오를 통해 테스트 순서를 미리 정함으로써 테스트 항목을 빠짐없이 수행할 수 있다

#### 테스트 오라클

테스트 오라클은 테스트 결과가 올바른지 판단하기 위해 사전에 정의된 참 값을 대입하여 비교하는 기법 및 활동

- 결과를 판단하기 위해 테스트 케이스에 대한 예상 결과를 계산하거나 확인
- 특징
  - 제한된 검증: 테스트 오라클을 모든 테스트 케이스에 적용할 수 없다
  - 수학적 기법: 테스트 오라클의 값을 수학적 기법을 이용하여 구할 수 있다
  - 자동화 기능: 테스트 대상 프로그램의 실행, 결과 비교, 커버리지 측정 등을 자동화할 수 있다
- 종류
  - 참(True) 오라클: 모든 테스트 케이스의 입력 값에 대해 기대하는 결과를 제공하는 오라클로, 발생된 모든 오류를 검토할 수 있다
  - 샘플링(Sampling) 오라클: 특정한 몇몇 테스트 케이스의 입력 값들에 대해서만 기대하는 결과를 제공하는 오라클
  - 추정(Heuristic) 오라클: 샘플링 오라클을 개선한 오라클로, 특정 테스트 케이스의 입력 값에 대해 기대하는 결과를 제공하고, 나머지 입력 값들에 대해서는 추정으로 처리하는 오라클
  - 일관성(Consistent) 검사 오라클: 애플리케이션의 변경이 있을 때, 테스트 케이스의 수행 전과 후의 결과 값이 동일한지를 확인하는 오라클

---
